#!/usr/bin/env python
import os
import sys
import argparse
import shutil
import glob
from zipit import Zipit
from dataclasses import dataclass


@dataclass
class Config:
    title: str
    version: str
    docheck: bool
    destination: str


class Zipr(Zipit):
    def __init__(self, args):
        super().__init__()
        self.args = args
        self.initialize()

    def initialize(self):
        Config.title = 'Zipr'
        Config.version = '2.01'
        Config.docheck = not self.args.nocheck
        Config.destination = 'archives'

    def check_if_in_archives(self, zipfilename):
        adir = os.path.expanduser(
            os.path.join('~', 'Games', 'archives')
            )
        udir = os.path.expanduser(
            os.path.join('~', 'USB', 'sexgames')
            )
        kdir = os.path.join(udir, 'keep')
        folders = [adir, udir, kdir]
        foundpaths = []
        found = False

        for folder in folders:
            checkpath = os.path.join(folder, zipfilename)
            if os.path.exists(checkpath):
                foundpaths.append(checkpath)
                found = True

        if found:
            response = self.askyesno('Archives found! Do you want to delete them?')
            if response:
                for path in foundpaths:
                    os.remove(path)
                self.print_info('Existing archives removed...', clearline=True)
            else:
                self.print_info('Keeping existing archives...', clearline=True)

    def check_destination(self):
        exited = False
        match self.args.dest.lower():
            case 'usb': Config.destination = os.path.expanduser(
                    os.path.join('~', 'USB', 'sexgames')
                    )
            case 'keep': Config.destination = os.path.expanduser(
                    os.path.join('~', 'USB', 'sexgames', 'keep')
                    )
            case 'archives': Config.destination = os.path.expanduser(
                    os.path.join('~', 'Games', 'archives')
                    )
            case _:
                self.print_err('Not a valid destination!')
                exited = True
        return exited

    def dochecks(self):
        exited = False
        zipfilename = self.args.folder + ".zip"

        if not exited:
            if not os.path.exists(self.args.folder):
                self.print_err(f"'{self.args.folder}' does not exist...")
                exited = True

        if not exited:
            exited = self.check_destination()

        if not exited:
            if os.path.exists(zipfilename):
                os.remove(zipfilename)

        if not exited:
            self.check_if_in_archives(zipfilename)

        if exited:
            self.print_err("Exiting!")
            self.toggle_cursor()
            sys.exit()

    def move_archive(self, sourcefile):
        source_size = os.stat(sourcefile).st_size
        target_fn = os.path.join(Config.destination, sourcefile)
        copied = 0
        source = open(sourcefile, 'rb')
        target = open(target_fn, 'wb')
        pbar = self.render_progressbar(copied, source_size, style=1)
        msg = f"{pbar} Copying {sourcefile} to {Config.destination}"
        self.print_info(msg, clearline=False)

        while True:
            chunk = source.read(32768)
            if not chunk:
                break
            target.write(chunk)
            copied += len(chunk)
            pbar = self.render_progressbar(copied, source_size, style=1)
            msg = f"{pbar} Copying {sourcefile} to {Config.destination}"
            self.print_info(msg, clearline=True)

        source.close()
        target.close()
        os.remove(sourcefile)

    def clear_saves(self):
        gamepath = self.args.folder
        checkpath = os.path.join(gamepath, '**', 'saves')
        savepaths = glob.iglob(checkpath, recursive=True)
        renpypath = os.path.expanduser(os.path.join('~', '.renpy'))
        foundpaths = [renpypath]
        curpath = os.getcwd()
        found = False
        for path in savepaths:
            foundpaths.append(os.path.join(curpath, path))
            found = True

        if found:
            self.print_info('Clearing saves...')
            for path in foundpaths:
                shutil.rmtree(path)

    def run(self):
        self.clear_saves()
        self.toggle_cursor()
        fulltitle = f"{Config.title} v{Config.version}"
        copyright = "Copyright Â© 2023 TransGirl"
        lines = [fulltitle, copyright]
        self.title(lines, clear=True, style=5)

        self.dochecks()
        self.clear_saves()
        self.compress(self.args.folder, check=Config.docheck, clevel=9)

        self.move_archive(self.args.folder + '.zip')

        if not self.args.keep:
            self.print_info('Removing source folder...')
            shutil.rmtree(self.args.folder)

        self.toggle_cursor()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('folder', help='Folder to zip')
    parser.add_argument('-d', '--dest',
                        required=False,
                        default='archives',
                        help='Destination for archive')
    parser.add_argument('-k', '--keep',
                        action='store_true',
                        required=False,
                        default=False,
                        help='Keep the source after copying')
    parser.add_argument('-nc', '--nocheck',
                        action='store_true',
                        required=False,
                        default=False,
                        help='Do a filecheck')

    args = parser.parse_args()
    app = Zipr(args)
    app.run()
